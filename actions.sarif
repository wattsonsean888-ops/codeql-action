{"$schema":"https://json.schemastore.org/sarif-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"CodeQL","organization":"GitHub","semanticVersion":"2.23.2","notifications":[{"id":"cli/expected-extracted-files/actions","name":"cli/expected-extracted-files/actions","shortDescription":{"text":"Expected extracted files"},"fullDescription":{"text":"Files appearing in the source archive that are expected to be extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["expected-extracted-files","telemetry"],"languageDisplayName":"GitHub Actions"}},{"id":"cli/platform","name":"cli/platform","shortDescription":{"text":"Platform"},"fullDescription":{"text":"Platform"},"defaultConfiguration":{"enabled":true}},{"id":"cli/build-mode","name":"cli/build-mode","shortDescription":{"text":"A build mode was specified"},"fullDescription":{"text":"A build mode was specified"},"defaultConfiguration":{"enabled":true}},{"id":"codeql-action/zstd-availability","name":"codeql-action/zstd-availability","shortDescription":{"text":"Zstandard availability"},"fullDescription":{"text":"Zstandard availability"},"defaultConfiguration":{"enabled":true}}],"rules":[]},"extensions":[{"name":"codeql/actions-queries","semanticVersion":"0.6.10+a05ffdbc810d58f3bf9cd44f48fab7b31fdea9fa","notifications":[{"id":"actions/diagnostics/successfully-extracted-files","name":"actions/diagnostics/successfully-extracted-files","shortDescription":{"text":"Extracted files"},"fullDescription":{"text":"List all files that were extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["successfully-extracted-files"],"description":"List all files that were extracted.","id":"actions/diagnostics/successfully-extracted-files","kind":"diagnostic","name":"Extracted files"}}],"rules":[{"id":"actions/improper-access-control","name":"actions/improper-access-control","shortDescription":{"text":"Improper Access Control"},"fullDescription":{"text":"The access control mechanism is not properly implemented, allowing untrusted code to be executed in a privileged context."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nSometimes labels are used to approve GitHub Actions. An authorization check may not be properly implemented, allowing an attacker to mutate the code after it has been reviewed and approved by label.\n\n## Recommendation\n\nWhen using labels, make sure that the code cannot be modified after it has been reviewed and the label has been set.\n\n## Example\n\n### Incorrect Usage\n\nThe following example shows a job that requires the label `safe to test` to be set before running untrusted code. There are two problems with the code:\n\n1. The workflow gets triggered on `synchronize` activity type and, therefore, it will get triggered every time there is a change in the Pull Request. An attacker can modify the code of the Pull Request after the code has been reviewed and the label has been set. The workflow will be triggered every time a new change is added to the Pull Request.\n2. The workflow uses `ref: ${{ github.event.pull_request.head.ref }}` for checkout, which is a branch name of the Pull Request. There is a window of opportunity for the attacker to modify their branch after the Pull Request is labeled, but before the workflow starts and runs the checkout.\n\n```yaml\non:\n  pull_request_target:\n    types: [opened, synchronize]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repo for OWNER TEST\n        uses: actions/checkout@v3\n        if: contains(github.event.pull_request.labels.*.name, 'safe to test')\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n      - run: ./cmd\n```\n\n### Correct Usage\n\nMake sure that the workflow only gets triggered when the label is set and use an immutable commit (`github.event.pull_request.head.sha`) instead of a mutable reference.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repo for OWNER TEST\n        uses: actions/checkout@v3\n        if: contains(github.event.pull_request.labels.*.name, 'safe to test')\n        with:\n          ref: ${{ github.event.pull_request.head.sha}}\n      - run: ./cmd\n```\n\n## References\n\n- GitHub Docs: [Events that trigger workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#pull_request_target).\n","markdown":"## Overview\n\nSometimes labels are used to approve GitHub Actions. An authorization check may not be properly implemented, allowing an attacker to mutate the code after it has been reviewed and approved by label.\n\n## Recommendation\n\nWhen using labels, make sure that the code cannot be modified after it has been reviewed and the label has been set.\n\n## Example\n\n### Incorrect Usage\n\nThe following example shows a job that requires the label `safe to test` to be set before running untrusted code. There are two problems with the code:\n\n1. The workflow gets triggered on `synchronize` activity type and, therefore, it will get triggered every time there is a change in the Pull Request. An attacker can modify the code of the Pull Request after the code has been reviewed and the label has been set. The workflow will be triggered every time a new change is added to the Pull Request.\n2. The workflow uses `ref: ${{ github.event.pull_request.head.ref }}` for checkout, which is a branch name of the Pull Request. There is a window of opportunity for the attacker to modify their branch after the Pull Request is labeled, but before the workflow starts and runs the checkout.\n\n```yaml\non:\n  pull_request_target:\n    types: [opened, synchronize]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repo for OWNER TEST\n        uses: actions/checkout@v3\n        if: contains(github.event.pull_request.labels.*.name, 'safe to test')\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n      - run: ./cmd\n```\n\n### Correct Usage\n\nMake sure that the workflow only gets triggered when the label is set and use an immutable commit (`github.event.pull_request.head.sha`) instead of a mutable reference.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repo for OWNER TEST\n        uses: actions/checkout@v3\n        if: contains(github.event.pull_request.labels.*.name, 'safe to test')\n        with:\n          ref: ${{ github.event.pull_request.head.sha}}\n      - run: ./cmd\n```\n\n## References\n\n- GitHub Docs: [Events that trigger workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#pull_request_target).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-285"],"description":"The access control mechanism is not properly implemented, allowing untrusted code to be executed in a privileged context.","id":"actions/improper-access-control","kind":"problem","name":"Improper Access Control","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"actions/vulnerable-action","name":"actions/vulnerable-action","shortDescription":{"text":"Use of a known vulnerable action"},"fullDescription":{"text":"The workflow is using an action with known vulnerabilities."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nThe security of the workflow and the repository could be compromised by GitHub Actions workflows that utilize GitHub Actions with known vulnerabilities.\n\n## Recommendation\n\nEither remove the component from the workflow or upgrade it to a version that is not vulnerable.\n\n## References\n\n- GitHub Docs: [Keeping your actions up to date with Dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot).\n","markdown":"## Overview\n\nThe security of the workflow and the repository could be compromised by GitHub Actions workflows that utilize GitHub Actions with known vulnerabilities.\n\n## Recommendation\n\nEither remove the component from the workflow or upgrade it to a version that is not vulnerable.\n\n## References\n\n- GitHub Docs: [Keeping your actions up to date with Dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-1395"],"description":"The workflow is using an action with known vulnerabilities.","id":"actions/vulnerable-action","kind":"problem","name":"Use of a known vulnerable action","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/secrets-in-artifacts","name":"actions/secrets-in-artifacts","shortDescription":{"text":"Storage of sensitive information in GitHub Actions artifact"},"fullDescription":{"text":"Including sensitive information in a GitHub Actions artifact can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nSensitive information included in a GitHub Actions artifact can allow an attacker to access the sensitive information if the artifact is published.\n\n## Recommendation\n\nOnly store information that is meant to be publicly available in a GitHub Actions artifact.\n\n## Example\n\n### Incorrect Usage\n\nThe following example uses `actions/checkout` to checkout code which stores the GITHUB_TOKEN in the \\`.git/config\\` file and then stores the contents of the \\`.git\\` repository into the artifact:\n\n```yaml\nname: secrets-in-artifacts\non:\n  pull_request:\njobs:\n  a-job: # VULNERABLE\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@1746f4ab65b179e0ea60a494b83293b640dd5bba # v4.3.2\n        with:\n          name: file\n          path: .\n```\n\n### Correct Usage\n\nThe issue has been fixed below, where the `actions/upload-artifact` uses a version (v4+) which does not include hidden files or directories into the artifact.\n\n```yaml\nname: secrets-in-artifacts\non:\n  pull_request:\njobs:\n  a-job: # NOT VULNERABLE\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@v4\n        with:\n          name: file\n          path: .\n```\n","markdown":"## Overview\n\nSensitive information included in a GitHub Actions artifact can allow an attacker to access the sensitive information if the artifact is published.\n\n## Recommendation\n\nOnly store information that is meant to be publicly available in a GitHub Actions artifact.\n\n## Example\n\n### Incorrect Usage\n\nThe following example uses `actions/checkout` to checkout code which stores the GITHUB_TOKEN in the \\`.git/config\\` file and then stores the contents of the \\`.git\\` repository into the artifact:\n\n```yaml\nname: secrets-in-artifacts\non:\n  pull_request:\njobs:\n  a-job: # VULNERABLE\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@1746f4ab65b179e0ea60a494b83293b640dd5bba # v4.3.2\n        with:\n          name: file\n          path: .\n```\n\n### Correct Usage\n\nThe issue has been fixed below, where the `actions/upload-artifact` uses a version (v4+) which does not include hidden files or directories into the artifact.\n\n```yaml\nname: secrets-in-artifacts\non:\n  pull_request:\njobs:\n  a-job: # NOT VULNERABLE\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@v4\n        with:\n          name: file\n          path: .\n```\n"},"properties":{"tags":["actions","security","external/cwe/cwe-312"],"description":"Including sensitive information in a GitHub Actions artifact can\n              expose it to an attacker.","id":"actions/secrets-in-artifacts","kind":"problem","name":"Storage of sensitive information in GitHub Actions artifact","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/excessive-secrets-exposure","name":"actions/excessive-secrets-exposure","shortDescription":{"text":"Excessive Secrets Exposure"},"fullDescription":{"text":"All organization and repository secrets are passed to the workflow runner."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"## Overview\n\nWhen the workflow runner cannot determine what secrets are needed to run the workflow, it will pass all the available secrets to the runner including organization and repository secrets. This violates the least privileged principle and increases the impact of a potential vulnerability affecting the workflow.\n\n## Recommendation\n\nOnly pass those secrets that are needed by the workflow. Avoid using expressions such as `toJSON(secrets)` or dynamically accessed secrets such as `secrets[format('GH_PAT_%s', matrix.env)]` since the workflow will need to receive all secrets to decide at runtime which one needs to be used.\n\n## Example\n\n### Incorrect Usage\n\n```yaml\nenv:\n  ALL_SECRETS: ${{ toJSON(secrets) }}\n```\n\n```yaml\nstrategy:\n  matrix:\n    env: [PROD, DEV]\nenv:\n  GH_TOKEN: ${{ secrets[format('GH_PAT_%s', matrix.env)] }}\n```\n\n### Correct Usage\n\n```yaml\nenv:\n  NEEDED_SECRET: ${{ secrets.GH_PAT }}\n```\n\n```yaml\nstrategy:\n  matrix:\n    env: [PROD, DEV]\n---\nif: matrix.env == \"PROD\"\nenv:\n  GH_TOKEN: ${{ secrets.GH_PAT_PROD }}\n---\nif: matrix.env == \"DEV\"\nenv:\n  GH_TOKEN: ${{ secrets.GH_PAT_DEV }}\n```\n\n## References\n\n- GitHub Docs: [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions#using-encrypted-secrets-in-a-workflow).\n- poutine: [Job uses all secrets](https://github.com/boostsecurityio/poutine/blob/main/docs/content/en/rules/job_all_secrets.md).\n","markdown":"## Overview\n\nWhen the workflow runner cannot determine what secrets are needed to run the workflow, it will pass all the available secrets to the runner including organization and repository secrets. This violates the least privileged principle and increases the impact of a potential vulnerability affecting the workflow.\n\n## Recommendation\n\nOnly pass those secrets that are needed by the workflow. Avoid using expressions such as `toJSON(secrets)` or dynamically accessed secrets such as `secrets[format('GH_PAT_%s', matrix.env)]` since the workflow will need to receive all secrets to decide at runtime which one needs to be used.\n\n## Example\n\n### Incorrect Usage\n\n```yaml\nenv:\n  ALL_SECRETS: ${{ toJSON(secrets) }}\n```\n\n```yaml\nstrategy:\n  matrix:\n    env: [PROD, DEV]\nenv:\n  GH_TOKEN: ${{ secrets[format('GH_PAT_%s', matrix.env)] }}\n```\n\n### Correct Usage\n\n```yaml\nenv:\n  NEEDED_SECRET: ${{ secrets.GH_PAT }}\n```\n\n```yaml\nstrategy:\n  matrix:\n    env: [PROD, DEV]\n---\nif: matrix.env == \"PROD\"\nenv:\n  GH_TOKEN: ${{ secrets.GH_PAT_PROD }}\n---\nif: matrix.env == \"DEV\"\nenv:\n  GH_TOKEN: ${{ secrets.GH_PAT_DEV }}\n```\n\n## References\n\n- GitHub Docs: [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions#using-encrypted-secrets-in-a-workflow).\n- poutine: [Job uses all secrets](https://github.com/boostsecurityio/poutine/blob/main/docs/content/en/rules/job_all_secrets.md).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-312"],"description":"All organization and repository secrets are passed to the workflow runner.","id":"actions/excessive-secrets-exposure","kind":"problem","name":"Excessive Secrets Exposure","precision":"high","problem.severity":"warning","security-severity":"5.0"}},{"id":"actions/unmasked-secret-exposure","name":"actions/unmasked-secret-exposure","shortDescription":{"text":"Unmasked Secret Exposure"},"fullDescription":{"text":"Secrets derived from other secrets are not masked by the workflow runner."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nSecrets derived from other secrets are not known to the workflow runner, and therefore are not masked unless explicitly registered.\n\n## Recommendation\n\nAvoid defining non-plain secrets. For example, do not define a new secret containing a JSON object and then read properties out of it from the workflow, since these read values will not be masked by the workflow runner.\n\n## Example\n\n### Incorrect Usage\n\n```yaml\n- env:\n    username: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}\n    password: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}\n  run: |\n    echo \"$username\"\n    echo \"$password\"\n```\n\n### Correct Usage\n\n```yaml\n- env:\n    username: ${{ secrets.AZURE_CREDENTIALS_CLIENT_ID }}\n    password: ${{ secrets.AZURE_CREDENTIALS_CLIENT_SECRET }}\n  run: |\n    echo \"$username\"\n    echo \"$password\"\n```\n\n## References\n\n- GitHub Docs: [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions#using-encrypted-secrets-in-a-workflow).\n","markdown":"## Overview\n\nSecrets derived from other secrets are not known to the workflow runner, and therefore are not masked unless explicitly registered.\n\n## Recommendation\n\nAvoid defining non-plain secrets. For example, do not define a new secret containing a JSON object and then read properties out of it from the workflow, since these read values will not be masked by the workflow runner.\n\n## Example\n\n### Incorrect Usage\n\n```yaml\n- env:\n    username: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}\n    password: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}\n  run: |\n    echo \"$username\"\n    echo \"$password\"\n```\n\n### Correct Usage\n\n```yaml\n- env:\n    username: ${{ secrets.AZURE_CREDENTIALS_CLIENT_ID }}\n    password: ${{ secrets.AZURE_CREDENTIALS_CLIENT_SECRET }}\n  run: |\n    echo \"$username\"\n    echo \"$password\"\n```\n\n## References\n\n- GitHub Docs: [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions#using-encrypted-secrets-in-a-workflow).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-312"],"description":"Secrets derived from other secrets are not masked by the workflow runner.","id":"actions/unmasked-secret-exposure","kind":"problem","name":"Unmasked Secret Exposure","precision":"high","problem.severity":"error","security-severity":"9.0"}},{"id":"actions/untrusted-checkout-toctou/critical","name":"actions/untrusted-checkout-toctou/critical","shortDescription":{"text":"Untrusted Checkout TOCTOU"},"fullDescription":{"text":"Untrusted Checkout is protected by a security check but the checked-out branch can be changed after the check."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nUntrusted Checkout is protected by a security check but the checked-out branch can be changed after the check.\n\n## Recommendation\n\nVerify that the code has not been modified after the security check. This may be achieved differently depending on the type of check:\n\n- Deployment Environment Approval: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n- Label Gates: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n\n## Example\n\n### Incorrect Usage (Deployment Environment Approval)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.ref }}\n      - run: ./cmd\n```\n\n### Correct Usage (Deployment Environment Approval)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.sha }}\n      - run: ./cmd\n```\n\n### Incorrect Usage (Label Gates)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n### Correct Usage (Label Gates)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n## References\n\n- [ActionsTOCTOU](https://github.com/AdnaneKhan/ActionsTOCTOU).\n","markdown":"## Overview\n\nUntrusted Checkout is protected by a security check but the checked-out branch can be changed after the check.\n\n## Recommendation\n\nVerify that the code has not been modified after the security check. This may be achieved differently depending on the type of check:\n\n- Deployment Environment Approval: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n- Label Gates: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n\n## Example\n\n### Incorrect Usage (Deployment Environment Approval)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.ref }}\n      - run: ./cmd\n```\n\n### Correct Usage (Deployment Environment Approval)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.sha }}\n      - run: ./cmd\n```\n\n### Incorrect Usage (Label Gates)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n### Correct Usage (Label Gates)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n## References\n\n- [ActionsTOCTOU](https://github.com/AdnaneKhan/ActionsTOCTOU).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-367"],"description":"Untrusted Checkout is protected by a security check but the checked-out branch can be changed after the check.","id":"actions/untrusted-checkout-toctou/critical","kind":"path-problem","name":"Untrusted Checkout TOCTOU","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"actions/untrusted-checkout-toctou/high","name":"actions/untrusted-checkout-toctou/high","shortDescription":{"text":"Untrusted Checkout TOCTOU"},"fullDescription":{"text":"Untrusted Checkout is protected by a security check but the checked-out branch can be changed after the check."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nUntrusted Checkout is protected by a security check but the checked-out branch can be changed after the check.\n\n## Recommendation\n\nVerify that the code has not been modified after the security check. This may be achieved differently depending on the type of check:\n\n- Deployment Environment Approval: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n- Label Gates: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n\n## Example\n\n### Incorrect Usage (Deployment Environment Approval)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.ref }}\n      - run: ./cmd\n```\n\n### Correct Usage (Deployment Environment Approval)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.sha }}\n      - run: ./cmd\n```\n\n### Incorrect Usage (Label Gates)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n### Correct Usage (Label Gates)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n## References\n\n- [ActionsTOCTOU](https://github.com/AdnaneKhan/ActionsTOCTOU).\n","markdown":"## Overview\n\nUntrusted Checkout is protected by a security check but the checked-out branch can be changed after the check.\n\n## Recommendation\n\nVerify that the code has not been modified after the security check. This may be achieved differently depending on the type of check:\n\n- Deployment Environment Approval: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n- Label Gates: Make sure to use a non-mutable reference to the code to be executed. For example use a `sha` instead of a `ref`.\n\n## Example\n\n### Incorrect Usage (Deployment Environment Approval)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.ref }}\n      - run: ./cmd\n```\n\n### Correct Usage (Deployment Environment Approval)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yml\non:\n  pull_request_target:\n    types: [Created]\njobs:\n  test:\n    environment: NeedsApproval\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout from PR branch\n        uses: actions/checkout@v4\n        with:\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n          ref: ${{ github.event.pull_request.head.sha }}\n      - run: ./cmd\n```\n\n### Incorrect Usage (Label Gates)\n\nThe following workflow uses a Deployment Environment which may be configured to require an approval. However, it check outs the code pointed to by the Pull Request branch reference. At attacker could submit legitimate code for review and then change it once it gets approved.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n### Correct Usage (Label Gates)\n\nUse immutable references (Commit SHA) to make sure that the reviewed code does not change between the check and the use.\n\n```yaml\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n          repository: ${{ github.event.pull_request.head.repo.full_name }}\n      - run: ./cmd\n```\n\n## References\n\n- [ActionsTOCTOU](https://github.com/AdnaneKhan/ActionsTOCTOU).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-367"],"description":"Untrusted Checkout is protected by a security check but the checked-out branch can be changed after the check.","id":"actions/untrusted-checkout-toctou/high","kind":"problem","name":"Untrusted Checkout TOCTOU","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/missing-workflow-permissions","name":"actions/missing-workflow-permissions","shortDescription":{"text":"Workflow does not contain permissions"},"fullDescription":{"text":"Workflows should contain explicit permissions to restrict the scope of the default GITHUB_TOKEN."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"## Overview\n\nIf a GitHub Actions job or workflow has no explicit permissions set, then the repository permissions are used. Repositories created under organizations inherit the organization permissions. The organizations or repositories created before February 2023 have the default permissions set to read-write. Often these permissions do not adhere to the principle of least privilege and can be reduced to read-only, leaving the `write` permission only to a specific types as `issues: write` or `pull-requests: write`.\n\n## Recommendation\n\nAdd the `permissions` key to the job or the root of workflow (in this case it is applied to all jobs in the workflow that do not have their own `permissions` key) and assign the least privileges required to complete the task.\n\n## Example\n\n### Incorrect Usage\n\n```yaml\nname: \"My workflow\"\n# No permissions block\n```\n\n### Correct Usage\n\n```yaml\nname: \"My workflow\"\npermissions:\n  contents: read\n  pull-requests: write\n```\n\nor\n\n```yaml\njobs:\n  my-job:\n    permissions:\n      contents: read\n      pull-requests: write\n```\n\n## References\n\n- GitHub Docs: [Assigning permissions to jobs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/assigning-permissions-to-jobs).\n","markdown":"## Overview\n\nIf a GitHub Actions job or workflow has no explicit permissions set, then the repository permissions are used. Repositories created under organizations inherit the organization permissions. The organizations or repositories created before February 2023 have the default permissions set to read-write. Often these permissions do not adhere to the principle of least privilege and can be reduced to read-only, leaving the `write` permission only to a specific types as `issues: write` or `pull-requests: write`.\n\n## Recommendation\n\nAdd the `permissions` key to the job or the root of workflow (in this case it is applied to all jobs in the workflow that do not have their own `permissions` key) and assign the least privileges required to complete the task.\n\n## Example\n\n### Incorrect Usage\n\n```yaml\nname: \"My workflow\"\n# No permissions block\n```\n\n### Correct Usage\n\n```yaml\nname: \"My workflow\"\npermissions:\n  contents: read\n  pull-requests: write\n```\n\nor\n\n```yaml\njobs:\n  my-job:\n    permissions:\n      contents: read\n      pull-requests: write\n```\n\n## References\n\n- GitHub Docs: [Assigning permissions to jobs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/assigning-permissions-to-jobs).\n"},"properties":{"tags":["actions","maintainability","security","external/cwe/cwe-275"],"description":"Workflows should contain explicit permissions to restrict the scope of the default GITHUB_TOKEN.","id":"actions/missing-workflow-permissions","kind":"problem","name":"Workflow does not contain permissions","precision":"high","problem.severity":"warning","security-severity":"5.0"}},{"id":"actions/cache-poisoning/direct-cache","name":"actions/cache-poisoning/direct-cache","shortDescription":{"text":"Cache Poisoning via caching of untrusted files"},"fullDescription":{"text":"The cache can be poisoned by untrusted code, leading to a cache poisoning attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub Actions cache poisoning is a technique that allows an attacker to inject malicious content into the Action's cache from unprivileged workflow, potentially leading to code execution in privileged workflows.\n\nAn attacker with the ability to run code in the context of the default branch (e.g. through Code Injection or Execution of Untrusted Code) can exploit this to:\n\n1. Steal the cache access token and URL.\n2. Overflow the cache to trigger eviction of legitimate entries.\n3. Poison cache entries with malicious payloads.\n4. Achieve code execution in privileged workflows that restore the poisoned cache.\n\nThis allows lateral movement from low-privileged to high-privileged workflows within a repository.\n\n### Cache Structure\n\nIn GitHub Actions, cache scopes are primarily determined by the branch structure. Branches are considered the main security boundary for GitHub Actions caching. This means that cache entries are generally scoped to specific branches.\n\n- **Access to Parent Branch Caches**: Feature branches (or child branches) created off of a parent branch (like `main` or `dev`) can access caches from the parent branch. For instance, a feature branch off of `main` will be able to access the cache from `main`.\n\n- **Sibling Branches**: Sibling branches, meaning branches that are created from the same parent but not from each other, do not share caches. For example, two branches created off of `main` will not be able to access each other’s caches directly.\n\nDue to the above design, if something is cached in the context of the default branch (e.g., `main`), it becomes accessible to any feature branch derived from `main`.\n\n## Recommendation\n\n1. Avoid using caching in workflows that handle sensitive operations like releases.\n2. If caching must be used:\n   - Validate restored cache contents before use.\n   - Use short-lived, workflow-specific cache keys.\n   - Clear caches regularly.\n3. Implement strict isolation between untrusted and privileged workflow execution.\n4. Never run untrusted code in the context of the default branch.\n5. Sign the cache value cryptographically and verify the signature before usage.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow is caching an attacker-controlled file (`large_file`) in the context of the default branch.\n\n```yaml\nname: Vulnerable Workflow\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pr-comment:\n    permissions: read-all\n    runs-on: ubuntu-latest\n    steps:\n      - uses: xt0rted/pull-request-comment-branch@v2\n        id: comment-branch\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ steps.comment-branch.outputs.head_sha }}\n      - name: Set up Python 3.10\n        uses: actions/setup-python@v5\n      - name: Cache pip dependencies\n        uses: actions/cache@v4\n        id: cache-pip\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n          restore-keys: ${{ runner.os }}-pip-\n```\n\n### Correct Usage\n\nThe following workflow checking out untrusted files, but the cache is scoped to the Pull Request.\n\n```yaml\nname: Secure Workflow\non:\n  pull_request:\n\njobs:\n  pr-comment:\n    permissions: read-all\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python 3.10\n        uses: actions/setup-python@v5\n      - name: Cache pip dependencies\n        uses: actions/cache@v4\n        id: cache-pip\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n          restore-keys: ${{ runner.os }}-pip-\n```\n\nNote, that the example above doesn't allow using secrets if the Pull Request originates from a fork. In case secrets are needed, `pull_request_target` with labels as `safe to test` can be used, but the code in Pull Request must be manually reviewed before applying the label.\n\n```yaml\nname: Secure Workflow\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  pr-comment:\n    if: contains(github.event.pull_request.labels.*.name, 'safe to test')\n    permissions: read-all\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha}}\n      - name: Set up Python 3.10\n        uses: actions/setup-python@v5\n      - name: Cache pip dependencies\n        uses: actions/cache@v4\n        id: cache-pip\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n          restore-keys: ${{ runner.os }}-pip-\n```\n\n## References\n\n- Adnan Khan's Blog: [The Monsters in Your Build Cache – GitHub Actions Cache Poisoning](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/).\n- GitHub Docs: [GitHub Actions Caching Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n- Scribe Security Blog: [Cache Poisoning in GitHub Actions](https://scribesecurity.com/blog/github-cache-poisoning/).\n","markdown":"## Overview\n\nGitHub Actions cache poisoning is a technique that allows an attacker to inject malicious content into the Action's cache from unprivileged workflow, potentially leading to code execution in privileged workflows.\n\nAn attacker with the ability to run code in the context of the default branch (e.g. through Code Injection or Execution of Untrusted Code) can exploit this to:\n\n1. Steal the cache access token and URL.\n2. Overflow the cache to trigger eviction of legitimate entries.\n3. Poison cache entries with malicious payloads.\n4. Achieve code execution in privileged workflows that restore the poisoned cache.\n\nThis allows lateral movement from low-privileged to high-privileged workflows within a repository.\n\n### Cache Structure\n\nIn GitHub Actions, cache scopes are primarily determined by the branch structure. Branches are considered the main security boundary for GitHub Actions caching. This means that cache entries are generally scoped to specific branches.\n\n- **Access to Parent Branch Caches**: Feature branches (or child branches) created off of a parent branch (like `main` or `dev`) can access caches from the parent branch. For instance, a feature branch off of `main` will be able to access the cache from `main`.\n\n- **Sibling Branches**: Sibling branches, meaning branches that are created from the same parent but not from each other, do not share caches. For example, two branches created off of `main` will not be able to access each other’s caches directly.\n\nDue to the above design, if something is cached in the context of the default branch (e.g., `main`), it becomes accessible to any feature branch derived from `main`.\n\n## Recommendation\n\n1. Avoid using caching in workflows that handle sensitive operations like releases.\n2. If caching must be used:\n   - Validate restored cache contents before use.\n   - Use short-lived, workflow-specific cache keys.\n   - Clear caches regularly.\n3. Implement strict isolation between untrusted and privileged workflow execution.\n4. Never run untrusted code in the context of the default branch.\n5. Sign the cache value cryptographically and verify the signature before usage.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow is caching an attacker-controlled file (`large_file`) in the context of the default branch.\n\n```yaml\nname: Vulnerable Workflow\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pr-comment:\n    permissions: read-all\n    runs-on: ubuntu-latest\n    steps:\n      - uses: xt0rted/pull-request-comment-branch@v2\n        id: comment-branch\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ steps.comment-branch.outputs.head_sha }}\n      - name: Set up Python 3.10\n        uses: actions/setup-python@v5\n      - name: Cache pip dependencies\n        uses: actions/cache@v4\n        id: cache-pip\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n          restore-keys: ${{ runner.os }}-pip-\n```\n\n### Correct Usage\n\nThe following workflow checking out untrusted files, but the cache is scoped to the Pull Request.\n\n```yaml\nname: Secure Workflow\non:\n  pull_request:\n\njobs:\n  pr-comment:\n    permissions: read-all\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python 3.10\n        uses: actions/setup-python@v5\n      - name: Cache pip dependencies\n        uses: actions/cache@v4\n        id: cache-pip\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n          restore-keys: ${{ runner.os }}-pip-\n```\n\nNote, that the example above doesn't allow using secrets if the Pull Request originates from a fork. In case secrets are needed, `pull_request_target` with labels as `safe to test` can be used, but the code in Pull Request must be manually reviewed before applying the label.\n\n```yaml\nname: Secure Workflow\non:\n  pull_request_target:\n    types: [labeled]\n\njobs:\n  pr-comment:\n    if: contains(github.event.pull_request.labels.*.name, 'safe to test')\n    permissions: read-all\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha}}\n      - name: Set up Python 3.10\n        uses: actions/setup-python@v5\n      - name: Cache pip dependencies\n        uses: actions/cache@v4\n        id: cache-pip\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n          restore-keys: ${{ runner.os }}-pip-\n```\n\n## References\n\n- Adnan Khan's Blog: [The Monsters in Your Build Cache – GitHub Actions Cache Poisoning](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/).\n- GitHub Docs: [GitHub Actions Caching Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n- Scribe Security Blog: [Cache Poisoning in GitHub Actions](https://scribesecurity.com/blog/github-cache-poisoning/).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-349"],"description":"The cache can be poisoned by untrusted code, leading to a cache poisoning attack.","id":"actions/cache-poisoning/direct-cache","kind":"path-problem","name":"Cache Poisoning via caching of untrusted files","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/cache-poisoning/poisonable-step","name":"actions/cache-poisoning/poisonable-step","shortDescription":{"text":"Cache Poisoning via execution of untrusted code"},"fullDescription":{"text":"The cache can be poisoned by untrusted code, leading to a cache poisoning attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub Actions cache poisoning is a technique that allows an attacker to inject malicious content into the Action's cache from unprivileged workflow, potentially leading to code execution in privileged workflows.\n\nAn attacker with the ability to run code in the context of the default branch (e.g. through Code Injection or Execution of Untrusted Code) can exploit this to:\n\n1. Steal the cache access token and URL.\n2. Overflow the cache to trigger eviction of legitimate entries.\n3. Poison cache entries with malicious payloads.\n4. Achieve code execution in privileged workflows that restore the poisoned cache.\n\nThis allows lateral movement from low-privileged to high-privileged workflows within a repository.\n\n### Cache Structure\n\nIn GitHub Actions, cache scopes are primarily determined by the branch structure. Branches are considered the main security boundary for GitHub Actions caching. This means that cache entries are generally scoped to specific branches.\n\n- **Access to Parent Branch Caches**: Feature branches (or child branches) created off of a parent branch (like `main` or `dev`) can access caches from the parent branch. For instance, a feature branch off of `main` will be able to access the cache from `main`.\n\n- **Sibling Branches**: Sibling branches, meaning branches that are created from the same parent but not from each other, do not share caches. For example, two branches created off of `main` will not be able to access each other’s caches directly.\n\nDue to the above design, if something is cached in the context of the default branch (e.g., `main`), it becomes accessible to any feature branch derived from `main`.\n\n## Recommendation\n\n1. Avoid using caching in workflows that handle sensitive operations like releases.\n2. If caching must be used:\n   - Validate restored cache contents before use.\n   - Use short-lived, workflow-specific cache keys.\n   - Clear caches regularly.\n3. Implement strict isolation between untrusted and privileged workflow execution.\n4. Never run untrusted code in the context of the default branch.\n5. Sign the cache value cryptographically and verify the signature before usage.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow runs untrusted code in a non-privileged job but in the context of the default branch.\n\n```yaml\nname: Vulnerable Workflow\non:\n  pull_request_target:\n    branches: [main]\npermissions: {}\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Run tests\n        run: ./run_tests.sh\n```\n\n### Correct Usage\n\nThe following workflow runs untrusted code in a non-privileged job and the cache is scoped to the Pull Request branch.\n\n```yaml\nname: Secure Workflow\non:\n  pull_request:\n    branches: [main]\npermissions: {}\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Run tests\n        run: ./run_tests.sh\n```\n\n## References\n\n- Adnan Khan's Blog: [The Monsters in Your Build Cache – GitHub Actions Cache Poisoning](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/).\n- GitHub Docs: [GitHub Actions Caching Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n- Scribe Security Blog: [Cache Poisoning in GitHub Actions](https://scribesecurity.com/blog/github-cache-poisoning/).\n","markdown":"## Overview\n\nGitHub Actions cache poisoning is a technique that allows an attacker to inject malicious content into the Action's cache from unprivileged workflow, potentially leading to code execution in privileged workflows.\n\nAn attacker with the ability to run code in the context of the default branch (e.g. through Code Injection or Execution of Untrusted Code) can exploit this to:\n\n1. Steal the cache access token and URL.\n2. Overflow the cache to trigger eviction of legitimate entries.\n3. Poison cache entries with malicious payloads.\n4. Achieve code execution in privileged workflows that restore the poisoned cache.\n\nThis allows lateral movement from low-privileged to high-privileged workflows within a repository.\n\n### Cache Structure\n\nIn GitHub Actions, cache scopes are primarily determined by the branch structure. Branches are considered the main security boundary for GitHub Actions caching. This means that cache entries are generally scoped to specific branches.\n\n- **Access to Parent Branch Caches**: Feature branches (or child branches) created off of a parent branch (like `main` or `dev`) can access caches from the parent branch. For instance, a feature branch off of `main` will be able to access the cache from `main`.\n\n- **Sibling Branches**: Sibling branches, meaning branches that are created from the same parent but not from each other, do not share caches. For example, two branches created off of `main` will not be able to access each other’s caches directly.\n\nDue to the above design, if something is cached in the context of the default branch (e.g., `main`), it becomes accessible to any feature branch derived from `main`.\n\n## Recommendation\n\n1. Avoid using caching in workflows that handle sensitive operations like releases.\n2. If caching must be used:\n   - Validate restored cache contents before use.\n   - Use short-lived, workflow-specific cache keys.\n   - Clear caches regularly.\n3. Implement strict isolation between untrusted and privileged workflow execution.\n4. Never run untrusted code in the context of the default branch.\n5. Sign the cache value cryptographically and verify the signature before usage.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow runs untrusted code in a non-privileged job but in the context of the default branch.\n\n```yaml\nname: Vulnerable Workflow\non:\n  pull_request_target:\n    branches: [main]\npermissions: {}\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Run tests\n        run: ./run_tests.sh\n```\n\n### Correct Usage\n\nThe following workflow runs untrusted code in a non-privileged job and the cache is scoped to the Pull Request branch.\n\n```yaml\nname: Secure Workflow\non:\n  pull_request:\n    branches: [main]\npermissions: {}\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Run tests\n        run: ./run_tests.sh\n```\n\n## References\n\n- Adnan Khan's Blog: [The Monsters in Your Build Cache – GitHub Actions Cache Poisoning](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/).\n- GitHub Docs: [GitHub Actions Caching Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n- Scribe Security Blog: [Cache Poisoning in GitHub Actions](https://scribesecurity.com/blog/github-cache-poisoning/).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-349"],"description":"The cache can be poisoned by untrusted code, leading to a cache poisoning attack.","id":"actions/cache-poisoning/poisonable-step","kind":"path-problem","name":"Cache Poisoning via execution of untrusted code","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/cache-poisoning/code-injection","name":"actions/cache-poisoning/code-injection","shortDescription":{"text":"Cache Poisoning via low-privileged code injection"},"fullDescription":{"text":"The cache can be poisoned by untrusted code, leading to a cache poisoning attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub Actions cache poisoning is a technique that allows an attacker to inject malicious content into the Action's cache from unprivileged workflow, potentially leading to code execution in privileged workflows.\n\nAn attacker with the ability to run code in the context of the default branch (e.g. through Code Injection or Execution of Untrusted Code) can exploit this to:\n\n1. Steal the cache access token and URL.\n2. Overflow the cache to trigger eviction of legitimate entries.\n3. Poison cache entries with malicious payloads.\n4. Achieve code execution in privileged workflows that restore the poisoned cache.\n\nThis allows lateral movement from low-privileged to high-privileged workflows within a repository.\n\n### Cache Structure\n\nIn GitHub Actions, cache scopes are primarily determined by the branch structure. Branches are considered the main security boundary for GitHub Actions caching. This means that cache entries are generally scoped to specific branches.\n\n- **Access to Parent Branch Caches**: Feature branches (or child branches) created off of a parent branch (like `main` or `dev`) can access caches from the parent branch. For instance, a feature branch off of `main` will be able to access the cache from `main`.\n\n- **Sibling Branches**: Sibling branches, meaning branches that are created from the same parent but not from each other, do not share caches. For example, two branches created off of `main` will not be able to access each other’s caches directly.\n\nDue to the above design, if something is cached in the context of the default branch (e.g., `main`), it becomes accessible to any feature branch derived from `main`.\n\n## Recommendation\n\n1. Avoid using caching in workflows that handle sensitive operations like releases.\n2. If caching must be used:\n   - Validate restored cache contents before use.\n   - Use short-lived, workflow-specific cache keys.\n   - Clear caches regularly.\n3. Implement strict isolation between untrusted and privileged workflow execution.\n4. Never run untrusted code in the context of the default branch.\n5. Sign the cache value cryptographically and verify the signature before usage.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow is vulnerable to code injection in a non-privileged job but in the context of the default branch.\n\n```yaml\nname: Vulnerable Workflow\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pr-comment:\n    permissions: {}\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo ${{ github.event.comment.body }}\n```\n\n### Correct Usage\n\nThe following workflow is not vulnerable to code injections even if it runs in the context of the default branch.\n\n```yaml\nname: Secure Workflow\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pr-comment:\n    permissions: {}\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          BODY: ${{ github.event.comment.body }}\n        run: |\n          echo \"$BODY\"\n```\n\n## References\n\n- Adnan Khan's Blog: [The Monsters in Your Build Cache – GitHub Actions Cache Poisoning](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/).\n- GitHub Docs: [GitHub Actions Caching Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n- Scribe Security Blog: [Cache Poisoning in GitHub Actions](https://scribesecurity.com/blog/github-cache-poisoning/).\n","markdown":"## Overview\n\nGitHub Actions cache poisoning is a technique that allows an attacker to inject malicious content into the Action's cache from unprivileged workflow, potentially leading to code execution in privileged workflows.\n\nAn attacker with the ability to run code in the context of the default branch (e.g. through Code Injection or Execution of Untrusted Code) can exploit this to:\n\n1. Steal the cache access token and URL.\n2. Overflow the cache to trigger eviction of legitimate entries.\n3. Poison cache entries with malicious payloads.\n4. Achieve code execution in privileged workflows that restore the poisoned cache.\n\nThis allows lateral movement from low-privileged to high-privileged workflows within a repository.\n\n### Cache Structure\n\nIn GitHub Actions, cache scopes are primarily determined by the branch structure. Branches are considered the main security boundary for GitHub Actions caching. This means that cache entries are generally scoped to specific branches.\n\n- **Access to Parent Branch Caches**: Feature branches (or child branches) created off of a parent branch (like `main` or `dev`) can access caches from the parent branch. For instance, a feature branch off of `main` will be able to access the cache from `main`.\n\n- **Sibling Branches**: Sibling branches, meaning branches that are created from the same parent but not from each other, do not share caches. For example, two branches created off of `main` will not be able to access each other’s caches directly.\n\nDue to the above design, if something is cached in the context of the default branch (e.g., `main`), it becomes accessible to any feature branch derived from `main`.\n\n## Recommendation\n\n1. Avoid using caching in workflows that handle sensitive operations like releases.\n2. If caching must be used:\n   - Validate restored cache contents before use.\n   - Use short-lived, workflow-specific cache keys.\n   - Clear caches regularly.\n3. Implement strict isolation between untrusted and privileged workflow execution.\n4. Never run untrusted code in the context of the default branch.\n5. Sign the cache value cryptographically and verify the signature before usage.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow is vulnerable to code injection in a non-privileged job but in the context of the default branch.\n\n```yaml\nname: Vulnerable Workflow\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pr-comment:\n    permissions: {}\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo ${{ github.event.comment.body }}\n```\n\n### Correct Usage\n\nThe following workflow is not vulnerable to code injections even if it runs in the context of the default branch.\n\n```yaml\nname: Secure Workflow\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pr-comment:\n    permissions: {}\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          BODY: ${{ github.event.comment.body }}\n        run: |\n          echo \"$BODY\"\n```\n\n## References\n\n- Adnan Khan's Blog: [The Monsters in Your Build Cache – GitHub Actions Cache Poisoning](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/).\n- GitHub Docs: [GitHub Actions Caching Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n- Scribe Security Blog: [Cache Poisoning in GitHub Actions](https://scribesecurity.com/blog/github-cache-poisoning/).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-349","external/cwe/cwe-094"],"description":"The cache can be poisoned by untrusted code, leading to a cache poisoning attack.","id":"actions/cache-poisoning/code-injection","kind":"path-problem","name":"Cache Poisoning via low-privileged code injection","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/artifact-poisoning/critical","name":"actions/artifact-poisoning/critical","shortDescription":{"text":"Artifact poisoning"},"fullDescription":{"text":"An attacker may be able to poison the workflow's artifacts and influence on consequent steps."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nThe workflow downloads artifacts that may be poisoned by an attacker in previously triggered workflows. If the contents of these artifacts are not correctly extracted, stored and verified, they may lead to repository compromise if untrusted code gets executed in a privileged job.\n\n## Recommendation\n\n- Always consider artifacts content as untrusted.\n- Extract the contents of artifacts to a temporary folder so they cannot override existing files.\n- Verify the contents of the artifacts downloaded. If an artifact is expected to contain a numeric value, verify it before using it.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow downloads an artifact that can potentially be controlled by an attacker and then runs a script from the runner workspace. Because the `dawidd6/action-download-artifact` by default downloads and extracts the contents of the artifacts overriding existing files, an attacker will be able to override the contents of `cmd.sh` and gain code execution when this file gets executed.\n\n```yaml\nname: Insecure Workflow\n\non:\n  workflow_run:\n    workflows: [\"Prev\"]\n    types:\n      - completed\n\njobs:\n  Download:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: dawidd6/action-download-artifact@v2\n        with:\n          name: pr_number\n      - name: Run command\n        run: |\n          sh cmd.sh\n```\n\n### Correct Usage\n\nThe following example, correctly creates a temporary directory and extracts the contents of the artifact there before calling `cmd.sh`.\n\n```yaml\nname: Secure Workflow\n\non:\n  workflow_run:\n    workflows: [\"Prev\"]\n    types:\n      - completed\n\njobs:\n  Download:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: mkdir -p ${{ runner.temp }}/artifacts/\n      - uses: dawidd6/action-download-artifact@v2\n        with:\n          name: pr_number\n          path: ${{ runner.temp }}/artifacts/\n\n      - name: Run command\n        run: |\n          sh cmd.sh\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).\n","markdown":"## Overview\n\nThe workflow downloads artifacts that may be poisoned by an attacker in previously triggered workflows. If the contents of these artifacts are not correctly extracted, stored and verified, they may lead to repository compromise if untrusted code gets executed in a privileged job.\n\n## Recommendation\n\n- Always consider artifacts content as untrusted.\n- Extract the contents of artifacts to a temporary folder so they cannot override existing files.\n- Verify the contents of the artifacts downloaded. If an artifact is expected to contain a numeric value, verify it before using it.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow downloads an artifact that can potentially be controlled by an attacker and then runs a script from the runner workspace. Because the `dawidd6/action-download-artifact` by default downloads and extracts the contents of the artifacts overriding existing files, an attacker will be able to override the contents of `cmd.sh` and gain code execution when this file gets executed.\n\n```yaml\nname: Insecure Workflow\n\non:\n  workflow_run:\n    workflows: [\"Prev\"]\n    types:\n      - completed\n\njobs:\n  Download:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: dawidd6/action-download-artifact@v2\n        with:\n          name: pr_number\n      - name: Run command\n        run: |\n          sh cmd.sh\n```\n\n### Correct Usage\n\nThe following example, correctly creates a temporary directory and extracts the contents of the artifact there before calling `cmd.sh`.\n\n```yaml\nname: Secure Workflow\n\non:\n  workflow_run:\n    workflows: [\"Prev\"]\n    types:\n      - completed\n\njobs:\n  Download:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: mkdir -p ${{ runner.temp }}/artifacts/\n      - uses: dawidd6/action-download-artifact@v2\n        with:\n          name: pr_number\n          path: ${{ runner.temp }}/artifacts/\n\n      - name: Run command\n        run: |\n          sh cmd.sh\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-829"],"description":"An attacker may be able to poison the workflow's artifacts and influence on consequent steps.","id":"actions/artifact-poisoning/critical","kind":"path-problem","name":"Artifact poisoning","precision":"very-high","problem.severity":"error","security-severity":"9"}},{"id":"actions/untrusted-checkout/critical","name":"actions/untrusted-checkout/critical","shortDescription":{"text":"Checkout of untrusted code in a privileged context"},"fullDescription":{"text":"Privileged workflows have read/write access to the base repository and access to secrets. By explicitly checking out and running the build script from a fork the untrusted code is running in an environment that is able to push to the base repository and to access secrets."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub workflows can be triggered through various repository events, including incoming pull requests (PRs) or comments on Issues/PRs. A potentially dangerous misuse of the triggers such as `pull_request_target` or `issue_comment` followed by an explicit checkout of untrusted code (Pull Request HEAD) may lead to repository compromise if untrusted code gets executed (e.g., due to a modified build script) in a privileged job.\n\n## Recommendation\n\n- Avoid using `pull_request_target` unless necessary.\n- Employ unprivileged `pull_request` workflows followed by `workflow_run` for privileged operations.\n- Use labels like `safe to test` to vet PRs and manage the execution context appropriately.\n\nThe best practice is to handle the potentially untrusted pull request via the **pull_request** trigger so that it is isolated in an unprivileged environment. The workflow processing the pull request should then store any results like code coverage or failed/passed tests in artifacts and exit. A second privileged workflow with the access to repository secrets, triggered by the completion of the first workflow using `workflow_run` trigger event, downloads the artifacts and make any necessary modifications to the repository or interact with third party services that require repository secrets (e.g. API tokens).\n\nThe artifacts downloaded from the first workflow should be considered untrusted and must be verified.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow checks-out untrusted code in a privileged context and runs user-controlled code (in this case package.json scripts) which will grant privileged access to the attacker:\n\n```yaml\non: pull_request_target\n\njobs:\n  build:\n    name: Build and test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - uses: actions/setup-node@v1\n      - run: |\n          npm install # scripts in package.json from PR would be executed here\n          npm build\n\n      - uses: completely/fakeaction@v2\n        with:\n          arg1: ${{ secrets.supersecret }}\n\n      - uses: fakerepo/comment-on-pr@v1\n        with:\n          message: |\n            Thank you!\n```\n\n### Correct Usage\n\nAn example shows how to use two workflows: one for processing the untrusted PR and the other for using the results in a safe context.\n\n**ReceivePR.yml** (untrusted PR handling with artifact creation):\n\n```yaml\nname: Receive PR\non:\n  pull_request:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build\n        run: /bin/bash ./build.sh\n      - name: Save PR number\n        run: |\n          mkdir -p ./pr\n          echo ${{ github.event.number }} > ./pr/NR\n      - uses: actions/upload-artifact@v2\n        with:\n          name: pr\n          path: pr/\n```\n\n**CommentPR.yml** (processing artifacts with privileged access):\n\n```yaml\nname: Comment on the pull request\non:\n  workflow_run:\n    workflows: [\"Receive PR\"]\n    types:\n      - completed\njobs:\n  upload:\n    runs-on: ubuntu-latest\n    if: >\n      github.event.workflow_run.event == 'pull_request' &&\n      github.event.workflow_run.conclusion == 'success'\n    steps:\n      - name: \"Download artifact\"\n        uses: actions/github-script@v3.1.0\n        with:\n          script: |\n            var artifacts = await github.actions.listWorkflowRunArtifacts({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                run_id: ${{github.event.workflow_run.id }},\n            });\n            var matchArtifact = artifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr\";\n            })[0];\n            var download = await github.actions.downloadArtifact({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                artifact_id: matchArtifact.id,\n                archive_format: 'zip',\n            });\n            var fs = require('fs');\n            fs.writeFileSync('${{github.workspace}}/pr.zip', Buffer.from(download.data));\n      - run: |\n          mkdir -p tmp\n          unzip -d tmp/ pr.zip\n      - name: \"Comment on PR\"\n        uses: actions/github-script@v3\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            var fs = require('fs');\n            var issue_number = Number(fs.readFileSync('./tmp/NR'));\n            // Verify that the file contains a numeric value\n            const contains_numeric = /\\d/.test(issue_number);\n            if (contains_numeric) {\n                await github.issues.createComment({\n                  owner: context.repo.owner,\n                  repo: context.repo.repo,\n                  issue_number: issue_number,\n                  body: 'Everything is OK. Thank you for the PR!'\n                });\n            }\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).\n","markdown":"## Overview\n\nGitHub workflows can be triggered through various repository events, including incoming pull requests (PRs) or comments on Issues/PRs. A potentially dangerous misuse of the triggers such as `pull_request_target` or `issue_comment` followed by an explicit checkout of untrusted code (Pull Request HEAD) may lead to repository compromise if untrusted code gets executed (e.g., due to a modified build script) in a privileged job.\n\n## Recommendation\n\n- Avoid using `pull_request_target` unless necessary.\n- Employ unprivileged `pull_request` workflows followed by `workflow_run` for privileged operations.\n- Use labels like `safe to test` to vet PRs and manage the execution context appropriately.\n\nThe best practice is to handle the potentially untrusted pull request via the **pull_request** trigger so that it is isolated in an unprivileged environment. The workflow processing the pull request should then store any results like code coverage or failed/passed tests in artifacts and exit. A second privileged workflow with the access to repository secrets, triggered by the completion of the first workflow using `workflow_run` trigger event, downloads the artifacts and make any necessary modifications to the repository or interact with third party services that require repository secrets (e.g. API tokens).\n\nThe artifacts downloaded from the first workflow should be considered untrusted and must be verified.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow checks-out untrusted code in a privileged context and runs user-controlled code (in this case package.json scripts) which will grant privileged access to the attacker:\n\n```yaml\non: pull_request_target\n\njobs:\n  build:\n    name: Build and test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - uses: actions/setup-node@v1\n      - run: |\n          npm install # scripts in package.json from PR would be executed here\n          npm build\n\n      - uses: completely/fakeaction@v2\n        with:\n          arg1: ${{ secrets.supersecret }}\n\n      - uses: fakerepo/comment-on-pr@v1\n        with:\n          message: |\n            Thank you!\n```\n\n### Correct Usage\n\nAn example shows how to use two workflows: one for processing the untrusted PR and the other for using the results in a safe context.\n\n**ReceivePR.yml** (untrusted PR handling with artifact creation):\n\n```yaml\nname: Receive PR\non:\n  pull_request:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build\n        run: /bin/bash ./build.sh\n      - name: Save PR number\n        run: |\n          mkdir -p ./pr\n          echo ${{ github.event.number }} > ./pr/NR\n      - uses: actions/upload-artifact@v2\n        with:\n          name: pr\n          path: pr/\n```\n\n**CommentPR.yml** (processing artifacts with privileged access):\n\n```yaml\nname: Comment on the pull request\non:\n  workflow_run:\n    workflows: [\"Receive PR\"]\n    types:\n      - completed\njobs:\n  upload:\n    runs-on: ubuntu-latest\n    if: >\n      github.event.workflow_run.event == 'pull_request' &&\n      github.event.workflow_run.conclusion == 'success'\n    steps:\n      - name: \"Download artifact\"\n        uses: actions/github-script@v3.1.0\n        with:\n          script: |\n            var artifacts = await github.actions.listWorkflowRunArtifacts({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                run_id: ${{github.event.workflow_run.id }},\n            });\n            var matchArtifact = artifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr\";\n            })[0];\n            var download = await github.actions.downloadArtifact({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                artifact_id: matchArtifact.id,\n                archive_format: 'zip',\n            });\n            var fs = require('fs');\n            fs.writeFileSync('${{github.workspace}}/pr.zip', Buffer.from(download.data));\n      - run: |\n          mkdir -p tmp\n          unzip -d tmp/ pr.zip\n      - name: \"Comment on PR\"\n        uses: actions/github-script@v3\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            var fs = require('fs');\n            var issue_number = Number(fs.readFileSync('./tmp/NR'));\n            // Verify that the file contains a numeric value\n            const contains_numeric = /\\d/.test(issue_number);\n            if (contains_numeric) {\n                await github.issues.createComment({\n                  owner: context.repo.owner,\n                  repo: context.repo.repo,\n                  issue_number: issue_number,\n                  body: 'Everything is OK. Thank you for the PR!'\n                });\n            }\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-829"],"description":"Privileged workflows have read/write access to the base repository and access to secrets.\n              By explicitly checking out and running the build script from a fork the untrusted code is running in an environment\n              that is able to push to the base repository and to access secrets.","id":"actions/untrusted-checkout/critical","kind":"path-problem","name":"Checkout of untrusted code in a privileged context","precision":"very-high","problem.severity":"error","security-severity":"9.3"}},{"id":"actions/untrusted-checkout/high","name":"actions/untrusted-checkout/high","shortDescription":{"text":"Checkout of untrusted code in trusted context"},"fullDescription":{"text":"Privileged workflows have read/write access to the base repository and access to secrets. By explicitly checking out and running the build script from a fork the untrusted code is running in an environment that is able to push to the base repository and to access secrets."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub workflows can be triggered through various repository events, including incoming pull requests (PRs) or comments on Issues/PRs. A potentially dangerous misuse of the triggers such as `pull_request_target` or `issue_comment` followed by an explicit checkout of untrusted code (Pull Request HEAD) may lead to repository compromise if untrusted code gets executed (e.g., due to a modified build script) in a privileged job.\n\n## Recommendation\n\n- Avoid using `pull_request_target` unless necessary.\n- Employ unprivileged `pull_request` workflows followed by `workflow_run` for privileged operations.\n- Use labels like `safe to test` to vet PRs and manage the execution context appropriately.\n\nThe best practice is to handle the potentially untrusted pull request via the **pull_request** trigger so that it is isolated in an unprivileged environment. The workflow processing the pull request should then store any results like code coverage or failed/passed tests in artifacts and exit. A second privileged workflow with the access to repository secrets, triggered by the completion of the first workflow using `workflow_run` trigger event, downloads the artifacts and make any necessary modifications to the repository or interact with third party services that require repository secrets (e.g. API tokens).\n\nThe artifacts downloaded from the first workflow should be considered untrusted and must be verified.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow checks-out untrusted code in a privileged context and runs user-controlled code (in this case package.json scripts) which will grant privileged access to the attacker:\n\n```yaml\non: pull_request_target\n\njobs:\n  build:\n    name: Build and test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - uses: actions/setup-node@v1\n      - run: |\n          npm install # scripts in package.json from PR would be executed here\n          npm build\n\n      - uses: completely/fakeaction@v2\n        with:\n          arg1: ${{ secrets.supersecret }}\n\n      - uses: fakerepo/comment-on-pr@v1\n        with:\n          message: |\n            Thank you!\n```\n\n### Correct Usage\n\nAn example shows how to use two workflows: one for processing the untrusted PR and the other for using the results in a safe context.\n\n**ReceivePR.yml** (untrusted PR handling with artifact creation):\n\n```yaml\nname: Receive PR\non:\n  pull_request:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build\n        run: /bin/bash ./build.sh\n      - name: Save PR number\n        run: |\n          mkdir -p ./pr\n          echo ${{ github.event.number }} > ./pr/NR\n      - uses: actions/upload-artifact@v2\n        with:\n          name: pr\n          path: pr/\n```\n\n**CommentPR.yml** (processing artifacts with privileged access):\n\n```yaml\nname: Comment on the pull request\non:\n  workflow_run:\n    workflows: [\"Receive PR\"]\n    types:\n      - completed\njobs:\n  upload:\n    runs-on: ubuntu-latest\n    if: >\n      github.event.workflow_run.event == 'pull_request' &&\n      github.event.workflow_run.conclusion == 'success'\n    steps:\n      - name: \"Download artifact\"\n        uses: actions/github-script@v3.1.0\n        with:\n          script: |\n            var artifacts = await github.actions.listWorkflowRunArtifacts({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                run_id: ${{github.event.workflow_run.id }},\n            });\n            var matchArtifact = artifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr\";\n            })[0];\n            var download = await github.actions.downloadArtifact({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                artifact_id: matchArtifact.id,\n                archive_format: 'zip',\n            });\n            var fs = require('fs');\n            fs.writeFileSync('${{github.workspace}}/pr.zip', Buffer.from(download.data));\n      - run: |\n          mkdir -p tmp\n          unzip -d tmp/ pr.zip\n      - name: \"Comment on PR\"\n        uses: actions/github-script@v3\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            var fs = require('fs');\n            var issue_number = Number(fs.readFileSync('./tmp/NR'));\n            // Verify that the file contains a numeric value\n            const contains_numeric = /\\d/.test(issue_number);\n            if (contains_numeric) {\n                await github.issues.createComment({\n                  owner: context.repo.owner,\n                  repo: context.repo.repo,\n                  issue_number: issue_number,\n                  body: 'Everything is OK. Thank you for the PR!'\n                });\n            }\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).\n","markdown":"## Overview\n\nGitHub workflows can be triggered through various repository events, including incoming pull requests (PRs) or comments on Issues/PRs. A potentially dangerous misuse of the triggers such as `pull_request_target` or `issue_comment` followed by an explicit checkout of untrusted code (Pull Request HEAD) may lead to repository compromise if untrusted code gets executed (e.g., due to a modified build script) in a privileged job.\n\n## Recommendation\n\n- Avoid using `pull_request_target` unless necessary.\n- Employ unprivileged `pull_request` workflows followed by `workflow_run` for privileged operations.\n- Use labels like `safe to test` to vet PRs and manage the execution context appropriately.\n\nThe best practice is to handle the potentially untrusted pull request via the **pull_request** trigger so that it is isolated in an unprivileged environment. The workflow processing the pull request should then store any results like code coverage or failed/passed tests in artifacts and exit. A second privileged workflow with the access to repository secrets, triggered by the completion of the first workflow using `workflow_run` trigger event, downloads the artifacts and make any necessary modifications to the repository or interact with third party services that require repository secrets (e.g. API tokens).\n\nThe artifacts downloaded from the first workflow should be considered untrusted and must be verified.\n\n## Example\n\n### Incorrect Usage\n\nThe following workflow checks-out untrusted code in a privileged context and runs user-controlled code (in this case package.json scripts) which will grant privileged access to the attacker:\n\n```yaml\non: pull_request_target\n\njobs:\n  build:\n    name: Build and test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - uses: actions/setup-node@v1\n      - run: |\n          npm install # scripts in package.json from PR would be executed here\n          npm build\n\n      - uses: completely/fakeaction@v2\n        with:\n          arg1: ${{ secrets.supersecret }}\n\n      - uses: fakerepo/comment-on-pr@v1\n        with:\n          message: |\n            Thank you!\n```\n\n### Correct Usage\n\nAn example shows how to use two workflows: one for processing the untrusted PR and the other for using the results in a safe context.\n\n**ReceivePR.yml** (untrusted PR handling with artifact creation):\n\n```yaml\nname: Receive PR\non:\n  pull_request:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build\n        run: /bin/bash ./build.sh\n      - name: Save PR number\n        run: |\n          mkdir -p ./pr\n          echo ${{ github.event.number }} > ./pr/NR\n      - uses: actions/upload-artifact@v2\n        with:\n          name: pr\n          path: pr/\n```\n\n**CommentPR.yml** (processing artifacts with privileged access):\n\n```yaml\nname: Comment on the pull request\non:\n  workflow_run:\n    workflows: [\"Receive PR\"]\n    types:\n      - completed\njobs:\n  upload:\n    runs-on: ubuntu-latest\n    if: >\n      github.event.workflow_run.event == 'pull_request' &&\n      github.event.workflow_run.conclusion == 'success'\n    steps:\n      - name: \"Download artifact\"\n        uses: actions/github-script@v3.1.0\n        with:\n          script: |\n            var artifacts = await github.actions.listWorkflowRunArtifacts({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                run_id: ${{github.event.workflow_run.id }},\n            });\n            var matchArtifact = artifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr\";\n            })[0];\n            var download = await github.actions.downloadArtifact({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                artifact_id: matchArtifact.id,\n                archive_format: 'zip',\n            });\n            var fs = require('fs');\n            fs.writeFileSync('${{github.workspace}}/pr.zip', Buffer.from(download.data));\n      - run: |\n          mkdir -p tmp\n          unzip -d tmp/ pr.zip\n      - name: \"Comment on PR\"\n        uses: actions/github-script@v3\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            var fs = require('fs');\n            var issue_number = Number(fs.readFileSync('./tmp/NR'));\n            // Verify that the file contains a numeric value\n            const contains_numeric = /\\d/.test(issue_number);\n            if (contains_numeric) {\n                await github.issues.createComment({\n                  owner: context.repo.owner,\n                  repo: context.repo.repo,\n                  issue_number: issue_number,\n                  body: 'Everything is OK. Thank you for the PR!'\n                });\n            }\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-829"],"description":"Privileged workflows have read/write access to the base repository and access to secrets.\n              By explicitly checking out and running the build script from a fork the untrusted code is running in an environment\n              that is able to push to the base repository and to access secrets.","id":"actions/untrusted-checkout/high","kind":"problem","name":"Checkout of untrusted code in trusted context","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"actions/envvar-injection/critical","name":"actions/envvar-injection/critical","shortDescription":{"text":"Environment variable built from user-controlled sources"},"fullDescription":{"text":"Building an environment variable from user-controlled sources may alter the execution of following system commands"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub Actions allow to define environment variables by writing to a file pointed to by the `GITHUB_ENV` environment variable:\n\nThis file contains lines in the `KEY=VALUE` format:\n\n```bash\nsteps:\n  - name: Set the value\n    id: step_one\n    run: |\n      echo \"action_state=yellow\" >> \"$GITHUB_ENV\"\n```\n\nIt is also possible to define multiline variables by using the [following construct](https://en.wikipedia.org/wiki/Here_document):\n\n```\nKEY<<{delimiter}\nVALUE\nVALUE\n{delimiter}\n```\n\n```bash\nsteps:\n  - name: Set the value in bash\n    id: step_one\n    run: |\n      {\n        echo 'JSON_RESPONSE<<EOF'\n        curl https://example.com\n        echo EOF\n      } >> \"$GITHUB_ENV\"\n```\n\nIf an attacker can control the values assigned to environment variables and there is no sanitization in place, the attacker will be able to inject additional variables by injecting new lines or `{delimiters}`.\n\n## Recommendation\n\n1. **Do not allow untrusted data to influence environment variables**:\n\n    - Avoid using untrusted data sources (e.g., artifact content) to define environment variables.\n    - Validate and sanitize all inputs before using them in environment settings.\n\n2. **Do not allow new lines when defining single line environment variables**:\n\n    - `echo \"BODY=$(echo \"$BODY\" | tr -d '\\n')\" >> \"$GITHUB_ENV\"`\n\n3. **Use unique identifiers when defining multi line environment variables**:\n\n    ```bash\n    steps:\n      - name: Set the value in bash\n        id: step_one\n        run: |\n          # Generate a UUID\n          UUID=$(uuidgen)\n          {\n            echo \"JSON_RESPONSE<<EOF$UUID\"\n            curl https://example.com\n            echo \"EOF$UUID\"\n          } >> \"$GITHUB_ENV\"\n    ```\n\n## Example\n\n### Example of Vulnerability\n\nConsider the following basic setup where an environment variable `MYVAR` is set and used in subsequent steps:\n\n```yaml\nsteps:\n  - name: Set the value\n    id: step_one\n    env:\n      BODY: ${{ github.event.comment.body }}\n    run: |\n      REPLACED=$(echo \"$BODY\" | sed 's/FOO/BAR/g')\n      echo \"MYVAR=$REPLACED\" >> \"$GITHUB_ENV\"\n```\n\nIf an attacker can manipulate the value being set, such as through artifact downloads or user inputs, the attacker can potentially inject new environment variables. For example, they could write an issue comment like:\n\n```text\nFOO\nNEW_ENV_VAR=MALICIOUS_VALUE\n```\n\nLikewise, if the attacker controls a file in the GitHub Actions Runner's workspace (eg: the workflow checkouts untrusted code or downloads an untrusted artifact) and the contents of that file are assigned to an environment variable such as:\n\n```bash\n- run: |\n    PR_NUMBER=$(cat pr-number.txt)\n    echo \"PR_NUMBER=$PR_NUMBER\" >> $GITHUB_ENV\n```\n\nAn attacker could craft a malicious artifact that writes dangerous environment variables:\n\n```bash\n  - run: |\n      echo -e \"666\\nNEW_ENV_VAR=MALICIOUS_VALUE\" > pr-number.txt\n  - uses: actions/upload-artifact@v4\n    with:\n      name: pr-number\n      path: ./pr-number.txt\n```\n\n### Exploitation\n\nAn attacker is be able to run arbitrary code by injecting environment variables such as `LD_PRELOAD`, `BASH_ENV`, etc.\n\n## References\n\n- GitHub Docs: [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions).\n- Synacktiv: [GitHub Actions Exploitation: Repo Jacking and Environment Manipulation](https://www.synacktiv.com/publications/github-actions-exploitation-repo-jacking-and-environment-manipulation).\n","markdown":"## Overview\n\nGitHub Actions allow to define environment variables by writing to a file pointed to by the `GITHUB_ENV` environment variable:\n\nThis file contains lines in the `KEY=VALUE` format:\n\n```bash\nsteps:\n  - name: Set the value\n    id: step_one\n    run: |\n      echo \"action_state=yellow\" >> \"$GITHUB_ENV\"\n```\n\nIt is also possible to define multiline variables by using the [following construct](https://en.wikipedia.org/wiki/Here_document):\n\n```\nKEY<<{delimiter}\nVALUE\nVALUE\n{delimiter}\n```\n\n```bash\nsteps:\n  - name: Set the value in bash\n    id: step_one\n    run: |\n      {\n        echo 'JSON_RESPONSE<<EOF'\n        curl https://example.com\n        echo EOF\n      } >> \"$GITHUB_ENV\"\n```\n\nIf an attacker can control the values assigned to environment variables and there is no sanitization in place, the attacker will be able to inject additional variables by injecting new lines or `{delimiters}`.\n\n## Recommendation\n\n1. **Do not allow untrusted data to influence environment variables**:\n\n    - Avoid using untrusted data sources (e.g., artifact content) to define environment variables.\n    - Validate and sanitize all inputs before using them in environment settings.\n\n2. **Do not allow new lines when defining single line environment variables**:\n\n    - `echo \"BODY=$(echo \"$BODY\" | tr -d '\\n')\" >> \"$GITHUB_ENV\"`\n\n3. **Use unique identifiers when defining multi line environment variables**:\n\n    ```bash\n    steps:\n      - name: Set the value in bash\n        id: step_one\n        run: |\n          # Generate a UUID\n          UUID=$(uuidgen)\n          {\n            echo \"JSON_RESPONSE<<EOF$UUID\"\n            curl https://example.com\n            echo \"EOF$UUID\"\n          } >> \"$GITHUB_ENV\"\n    ```\n\n## Example\n\n### Example of Vulnerability\n\nConsider the following basic setup where an environment variable `MYVAR` is set and used in subsequent steps:\n\n```yaml\nsteps:\n  - name: Set the value\n    id: step_one\n    env:\n      BODY: ${{ github.event.comment.body }}\n    run: |\n      REPLACED=$(echo \"$BODY\" | sed 's/FOO/BAR/g')\n      echo \"MYVAR=$REPLACED\" >> \"$GITHUB_ENV\"\n```\n\nIf an attacker can manipulate the value being set, such as through artifact downloads or user inputs, the attacker can potentially inject new environment variables. For example, they could write an issue comment like:\n\n```text\nFOO\nNEW_ENV_VAR=MALICIOUS_VALUE\n```\n\nLikewise, if the attacker controls a file in the GitHub Actions Runner's workspace (eg: the workflow checkouts untrusted code or downloads an untrusted artifact) and the contents of that file are assigned to an environment variable such as:\n\n```bash\n- run: |\n    PR_NUMBER=$(cat pr-number.txt)\n    echo \"PR_NUMBER=$PR_NUMBER\" >> $GITHUB_ENV\n```\n\nAn attacker could craft a malicious artifact that writes dangerous environment variables:\n\n```bash\n  - run: |\n      echo -e \"666\\nNEW_ENV_VAR=MALICIOUS_VALUE\" > pr-number.txt\n  - uses: actions/upload-artifact@v4\n    with:\n      name: pr-number\n      path: ./pr-number.txt\n```\n\n### Exploitation\n\nAn attacker is be able to run arbitrary code by injecting environment variables such as `LD_PRELOAD`, `BASH_ENV`, etc.\n\n## References\n\n- GitHub Docs: [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions).\n- Synacktiv: [GitHub Actions Exploitation: Repo Jacking and Environment Manipulation](https://www.synacktiv.com/publications/github-actions-exploitation-repo-jacking-and-environment-manipulation).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-077","external/cwe/cwe-020"],"description":"Building an environment variable from user-controlled sources may alter the execution of following system commands","id":"actions/envvar-injection/critical","kind":"path-problem","name":"Environment variable built from user-controlled sources","precision":"very-high","problem.severity":"error","security-severity":"9"}},{"id":"actions/envpath-injection/critical","name":"actions/envpath-injection/critical","shortDescription":{"text":"PATH environment variable built from user-controlled sources"},"fullDescription":{"text":"Building the PATH environment variable from user-controlled sources may alter the execution of following system commands"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nGitHub Actions allow to define the system PATH variable by writing to a file pointed to by the `GITHUB_PATH` environment variable. Writing to this file appends a directory to the system PATH variable and automatically makes it available to all subsequent actions in the current job.\n\nE.g.:\n\n```bash\necho \"$HOME/.local/bin\" >> $GITHUB_PATH\n```\n\nIf an attacker can control the contents of the system PATH, they are able to influence what commands are run in subsequent steps of the same job.\n\n## Recommendation\n\nDo not allow untrusted data to influence the system PATH: Avoid using untrusted data sources (e.g., artifact content) to define the system PATH.\n\n## Example\n\n### Incorrect Usage\n\nConsider the following basic setup where an environment variable `PATH` is set:\n\n```yaml\nsteps:\n  - name: Set the path\n    env:\n      BODY: ${{ github.event.comment.body }}\n    run: |\n      PATH=$(echo \"$BODY\" | grep -oP 'system path: \\K\\S+')\n      echo \"$PATH\" >> \"$GITHUB_PATH\"\n```\n\nIf an attacker can manipulate the value being set, such as through artifact downloads or user inputs, they can potentially change the system PATH and get arbitrary command execution in subsequent steps.\n\n## References\n\n- GitHub Docs: [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions).\n","markdown":"## Overview\n\nGitHub Actions allow to define the system PATH variable by writing to a file pointed to by the `GITHUB_PATH` environment variable. Writing to this file appends a directory to the system PATH variable and automatically makes it available to all subsequent actions in the current job.\n\nE.g.:\n\n```bash\necho \"$HOME/.local/bin\" >> $GITHUB_PATH\n```\n\nIf an attacker can control the contents of the system PATH, they are able to influence what commands are run in subsequent steps of the same job.\n\n## Recommendation\n\nDo not allow untrusted data to influence the system PATH: Avoid using untrusted data sources (e.g., artifact content) to define the system PATH.\n\n## Example\n\n### Incorrect Usage\n\nConsider the following basic setup where an environment variable `PATH` is set:\n\n```yaml\nsteps:\n  - name: Set the path\n    env:\n      BODY: ${{ github.event.comment.body }}\n    run: |\n      PATH=$(echo \"$BODY\" | grep -oP 'system path: \\K\\S+')\n      echo \"$PATH\" >> \"$GITHUB_PATH\"\n```\n\nIf an attacker can manipulate the value being set, such as through artifact downloads or user inputs, they can potentially change the system PATH and get arbitrary command execution in subsequent steps.\n\n## References\n\n- GitHub Docs: [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-077","external/cwe/cwe-020"],"description":"Building the PATH environment variable from user-controlled sources may alter the execution of following system commands","id":"actions/envpath-injection/critical","kind":"path-problem","name":"PATH environment variable built from user-controlled sources","precision":"very-high","problem.severity":"error","security-severity":"9"}},{"id":"actions/code-injection/critical","name":"actions/code-injection/critical","shortDescription":{"text":"Code injection"},"fullDescription":{"text":"Interpreting unsanitized user input as code allows a malicious user to perform arbitrary code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"## Overview\n\nUsing user-controlled input in GitHub Actions may lead to code injection in contexts like _run:_ or _script:_.\n\nCode injection in GitHub Actions may allow an attacker to exfiltrate any secrets used in the workflow and the temporary GitHub repository authorization token. The token may have write access to the repository, allowing an attacker to make changes to the repository.\n\n## Recommendation\n\nThe best practice to avoid code injection vulnerabilities in GitHub workflows is to set the untrusted input value of the expression to an intermediate environment variable and then use the environment variable using the native syntax of the shell/script interpreter (that is, not _${{ env.VAR }}_).\n\nIt is also recommended to limit the permissions of any tokens used by a workflow such as the GITHUB_TOKEN.\n\n## Example\n\n### Incorrect Usage\n\nThe following example lets attackers inject an arbitrary shell command:\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo '${{ github.event.comment.body }}'\n```\n\nThe following example uses an environment variable, but **still allows the injection** because of the use of expression syntax:\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n    -  env:\n        BODY: ${{ github.event.issue.body }}\n      run: |\n        echo '${{ env.BODY }}'\n```\n\n### Correct Usage\n\nThe following example uses shell syntax to read the environment variable and will prevent the attack:\n\n```yaml\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          BODY: ${{ github.event.issue.body }}\n        run: |\n          echo \"$BODY\"\n```\n\nThe following example uses `process.env` to read environment variables within JavaScript code.\n\n```yaml\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: uses: actions/github-script@v4\n        env:\n          BODY: ${{ github.event.issue.body }}\n        with:\n          script: |\n            const { BODY } = process.env\n            ...\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure: Untrusted input](https://securitylab.github.com/research/github-actions-untrusted-input).\n- GitHub Docs: [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions).\n- GitHub Docs: [Permissions for the GITHUB_TOKEN](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).\n","markdown":"## Overview\n\nUsing user-controlled input in GitHub Actions may lead to code injection in contexts like _run:_ or _script:_.\n\nCode injection in GitHub Actions may allow an attacker to exfiltrate any secrets used in the workflow and the temporary GitHub repository authorization token. The token may have write access to the repository, allowing an attacker to make changes to the repository.\n\n## Recommendation\n\nThe best practice to avoid code injection vulnerabilities in GitHub workflows is to set the untrusted input value of the expression to an intermediate environment variable and then use the environment variable using the native syntax of the shell/script interpreter (that is, not _${{ env.VAR }}_).\n\nIt is also recommended to limit the permissions of any tokens used by a workflow such as the GITHUB_TOKEN.\n\n## Example\n\n### Incorrect Usage\n\nThe following example lets attackers inject an arbitrary shell command:\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo '${{ github.event.comment.body }}'\n```\n\nThe following example uses an environment variable, but **still allows the injection** because of the use of expression syntax:\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n    -  env:\n        BODY: ${{ github.event.issue.body }}\n      run: |\n        echo '${{ env.BODY }}'\n```\n\n### Correct Usage\n\nThe following example uses shell syntax to read the environment variable and will prevent the attack:\n\n```yaml\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          BODY: ${{ github.event.issue.body }}\n        run: |\n          echo \"$BODY\"\n```\n\nThe following example uses `process.env` to read environment variables within JavaScript code.\n\n```yaml\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: uses: actions/github-script@v4\n        env:\n          BODY: ${{ github.event.issue.body }}\n        with:\n          script: |\n            const { BODY } = process.env\n            ...\n```\n\n## References\n\n- GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure: Untrusted input](https://securitylab.github.com/research/github-actions-untrusted-input).\n- GitHub Docs: [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions).\n- GitHub Docs: [Permissions for the GITHUB_TOKEN](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).\n"},"properties":{"tags":["actions","security","external/cwe/cwe-094","external/cwe/cwe-095","external/cwe/cwe-116"],"description":"Interpreting unsanitized user input as code allows a malicious user to perform arbitrary\n              code execution.","id":"actions/code-injection/critical","kind":"path-problem","name":"Code injection","precision":"very-high","problem.severity":"error","security-severity":"9"}}],"locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/actions-all","semanticVersion":"0.4.18+a05ffdbc810d58f3bf9cd44f48fab7b31fdea9fa","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/.codeql/libraries/codeql/actions-all/0.4.18/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/.codeql/libraries/codeql/actions-all/0.4.18/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/javascript-all","semanticVersion":"2.6.12+a05ffdbc810d58f3bf9cd44f48fab7b31fdea9fa","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/.codeql/libraries/codeql/javascript-all/2.6.12/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/.codeql/libraries/codeql/javascript-all/2.6.12/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/threat-models","semanticVersion":"1.0.32+a05ffdbc810d58f3bf9cd44f48fab7b31fdea9fa","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/.codeql/libraries/codeql/threat-models/1.0.32/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.2/x64/codeql/qlpacks/codeql/actions-queries/0.6.10/.codeql/libraries/codeql/threat-models/1.0.32/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]}]},"invocations":[{"toolExecutionNotifications":[{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/linter.yml","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"actions/diagnostics/successfully-extracted-files","index":0,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/check-variables.yml","uriBaseId":"%SRCROOT%","index":1}}}],"message":{"text":""},"level":"none","descriptor":{"id":"actions/diagnostics/successfully-extracted-files","index":0,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"action.yml","uriBaseId":"%SRCROOT%","index":2}}}],"message":{"text":""},"level":"none","descriptor":{"id":"actions/diagnostics/successfully-extracted-files","index":0,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/v5-tests-and-release.yml","uriBaseId":"%SRCROOT%","index":3}}}],"message":{"text":""},"level":"none","descriptor":{"id":"actions/diagnostics/successfully-extracted-files","index":0,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"action.yml","uriBaseId":"%SRCROOT%","index":2}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/actions","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/check-variables.yml","uriBaseId":"%SRCROOT%","index":1}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/actions","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/v5-tests-and-release.yml","uriBaseId":"%SRCROOT%","index":3}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/actions","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/linter.yml","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/actions","index":0},"properties":{"formattedMessage":{"text":""}}},{"message":{"text":"On the Linux (amd64; 6.14.0-1012-azure) platform.","markdown":"On the Linux (amd64; 6.14.0-1012-azure) platform."},"level":"none","timeUtc":"2025-10-19T21:37:48.788470974Z","descriptor":{"id":"cli/platform","index":1},"properties":{"attributes":{"arch":"amd64","name":"Linux","version":"6.14.0-1012-azure"},"visibility":{"statusPage":false,"telemetry":true}}},{"message":{"text":"The none build mode was specified.","markdown":"The none build mode was specified."},"level":"none","timeUtc":"2025-10-19T21:37:48.808813253Z","descriptor":{"id":"cli/build-mode","index":2},"properties":{"attributes":{"buildMode":"none"},"visibility":{"statusPage":false,"telemetry":true}}},{"message":{"text":""},"level":"none","timeUtc":"2025-10-19T21:37:42.350Z","descriptor":{"id":"codeql-action/zstd-availability","index":3},"properties":{"attributes":{"available":true,"foundZstdBinary":true,"version":{"type":"gnu","version":"1.35"}},"visibility":{"statusPage":false,"telemetry":true}}}],"executionSuccessful":true}],"artifacts":[{"location":{"uri":".github/workflows/linter.yml","uriBaseId":"%SRCROOT%","index":0}},{"location":{"uri":".github/workflows/check-variables.yml","uriBaseId":"%SRCROOT%","index":1}},{"location":{"uri":"action.yml","uriBaseId":"%SRCROOT%","index":2}},{"location":{"uri":".github/workflows/v5-tests-and-release.yml","uriBaseId":"%SRCROOT%","index":3}}],"results":[],"automationDetails":{"id":"/language:actions/"},"newlineSequences":["\r\n","\n"," "," "],"columnKind":"utf16CodeUnits","properties":{"semmle.formatSpecifier":"sarif-latest","codeqlConfigSummary":{"disableDefaultQueries":false},"jobRunUuid":"20b9ca36-acf3-4c46-9f5f-01040b7db724"}}]}